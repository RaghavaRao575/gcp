# Example dates
$date1 = "2025-01-12 23:30:00"   # January 12, 2025, 11:30 PM
$date2 = "01/10/2025 10:00 AM"   # January 10, 2025, 10:00 AM

# Parse the dates
$parsedDate1 = [datetime]::ParseExact($date1, "yyyy-MM-dd HH:mm:ss", $null)
$parsedDate2 = [datetime]::ParseExact($date2, "MM/dd/yyyy hh:mm tt", $null)

# Calculate the difference
$timeDifference = $parsedDate1 - $parsedDate2

# Add the difference to $date1
$newDate = $parsedDate1.Add($timeDifference)

# Output the results
Write-Output "Original Date1: $parsedDate1"
Write-Output "Original Date2: $parsedDate2"
Write-Output "Time Difference: $timeDifference"
Write-Output "New Date (Date1 + Difference): $newDate


I want you to implement the correct Dell EMC PowerMax / VMAX WWN-to-Device-ID decoding logic.
Use the following exact rules:

Take the last 4 hexadecimal characters of the WWN/NAA value.
Example: WWN ending "3038".

Split those 4 characters into two bytes.
Example: "3038" → "30" and "38".

Convert each byte from hex → ASCII character.
Example:
0x30 → ASCII '0'
0x38 → ASCII '8'

Combine the ASCII characters into a two-character string.
Example: "0" + "8" = "08".

Interpret that two-character string as a hex number.
Example: "08" → hex value 0x08.

Add the array offset 0x1000 to this value.
Example: 0x1000 + 0x08 = 0x0108.

The final value (padded to 4 hex digits) is the Device ID.
Example: Device ID = "0108".

Apply this logic for all WWN endings (ASCII-encoded ones such as “4143”, “3246”, “4537”, etc.) so that:

3038 → 0108

3246 → 012F

4143 → 01AC

4537 → 01E7
